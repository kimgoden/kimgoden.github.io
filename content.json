{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/11/02/hello-world/"},{"title":"Pandas 기초 사용법","text":"Pandas 사용123import pandas as pdprint(pd.__version__)# pandas 사용환경 설정 1.1.5 1import numpy as np 테스트12df = pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]})print(type(df)) &lt;class 'pandas.core.frame.DataFrame'&gt; 구글 드라이브와 연동123from google.colab import drivedrive.mount('/content/drive')# 구글 드라이브와 colab을 연동하여 드라이브의 파일을 가져올 수 있다. Mounted at /content/drive 123456789101112131415DATA_PATH = &quot;경로를 입력하시기를 바랍니다.&quot;DATA_PATH = '/content/drive/MyDrive/lectures_210923/PART_I_Intro/'&quot;&quot;&quot; 파일을 불러올 때는 경로를 잘 확인하여야 한다. 이 형식처럼 경로를 나눠저 적어도 되지만 DATA_PATH = '/content/drive/MyDrive/lectures_210923/PART_I_Intro/data/Lemonade2016.csv' lemonade = pd.read_csv(DATA_PATH) 위의 형식처럼 작성해도 된다.&quot;&quot;&quot;lemonade = pd.read_csv(DATA_PATH + 'data/Lemonade2016.csv')lemonade.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB 데이터 확인하기123lemonade.head(5)# 데이터프레임의 상단 5개 데이터를 불러온다.# lemonade.head() =&gt; 이렇게 공백으로 넣을 경우 기본값이 5로 되어 있다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 123lemonade.tail(5)# 데이터프레임의 하단 5개 데이터를 불러온다.# lemonade.tail() =&gt; 이렇게 공백으로 넣을 경우 기본값이 5로 되어 있다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 27 7/27/2016 Park 104 68 80 99.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 1234567891011print(lemonade.info())&quot;&quot;&quot;데이터 셋의 정보를 볼 수 있다.데이터 셋 행은 총 31, 열은 7 개로 구성되어져 있다.&quot;&quot;&quot;print(lemonade.index)# 데이터프레임의 인덱스 확인print(lemonade.columns)# 데이터프레임의 컬럼(행)을 확인 할 수 있다.print(lemonade.values)# numpy 데이터의 값을 확인 할 수 있다. &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB None RangeIndex(start=0, stop=32, step=1) Index(['Date', 'Location', 'Lemon', 'Orange', 'Temperature', 'Leaflets', 'Price'], dtype='object') [['7/1/2016' 'Park' 97 67 70 90.0 0.25] ['7/2/2016' 'Park' 98 67 72 90.0 0.25] ['7/3/2016' 'Park' 110 77 71 104.0 0.25] ['7/4/2016' 'Beach' 134 99 76 98.0 0.25] ['7/5/2016' 'Beach' 159 118 78 135.0 0.25] ['7/6/2016' 'Beach' 103 69 82 90.0 0.25] ['7/6/2016' 'Beach' 103 69 82 90.0 0.25] ['7/7/2016' 'Beach' 143 101 81 135.0 0.25] [nan 'Beach' 123 86 82 113.0 0.25] ['7/9/2016' 'Beach' 134 95 80 126.0 0.25] ['7/10/2016' 'Beach' 140 98 82 131.0 0.25] ['7/11/2016' 'Beach' 162 120 83 135.0 0.25] ['7/12/2016' 'Beach' 130 95 84 99.0 0.25] ['7/13/2016' 'Beach' 109 75 77 99.0 0.25] ['7/14/2016' 'Beach' 122 85 78 113.0 0.25] ['7/15/2016' 'Beach' 98 62 75 108.0 0.5] ['7/16/2016' 'Beach' 81 50 74 90.0 0.5] ['7/17/2016' 'Beach' 115 76 77 126.0 0.5] ['7/18/2016' 'Park' 131 92 81 122.0 0.5] ['7/19/2016' 'Park' 122 85 78 113.0 0.5] ['7/20/2016' 'Park' 71 42 70 nan 0.5] ['7/21/2016' 'Park' 83 50 77 90.0 0.5] ['7/22/2016' 'Park' 112 75 80 108.0 0.5] ['7/23/2016' 'Park' 120 82 81 117.0 0.5] ['7/24/2016' 'Park' 121 82 82 117.0 0.5] ['7/25/2016' 'Park' 156 113 84 135.0 0.5] ['7/26/2016' 'Park' 176 129 83 158.0 0.35] ['7/27/2016' 'Park' 104 68 80 99.0 0.35] ['7/28/2016' 'Park' 96 63 82 90.0 0.35] ['7/29/2016' 'Park' 100 66 81 95.0 0.35] ['7/30/2016' 'Beach' 88 57 82 81.0 0.35] ['7/31/2016' 'Beach' 76 47 82 68.0 0.35]] 12345678910lemonade.describe()# 간단한 통계 정보를 보여주는 메서드다.# count : 컬럼별 데이터의 개수# mean : 데이터의 평균값# std : 표준편차# min : 최솟값# 25%, 50%, 75% ; 4분위 수# max : 최댓값 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Lemon Orange Temperature Leaflets Price Sold Revenue count 32.000000 32.000000 32.000000 31.000000 32.000000 32.000000 32.000000 mean 116.156250 80.000000 78.968750 108.548387 0.354687 196.156250 68.156250 std 25.823357 21.863211 4.067847 20.117718 0.113137 47.647976 24.645531 min 71.000000 42.000000 70.000000 68.000000 0.250000 113.000000 41.000000 25% 98.000000 66.750000 77.000000 90.000000 0.250000 164.750000 51.500000 50% 113.500000 76.500000 80.500000 108.000000 0.350000 189.000000 58.875000 75% 131.750000 95.000000 82.000000 124.000000 0.500000 226.000000 83.375000 max 176.000000 129.000000 84.000000 158.000000 0.500000 305.000000 134.500000 123lemonade.T# 데이터 프레임에서 인덱스와 컬럼을 바꾼형태 입니다.# 이때 주의할 점은 .T는 메서드가 아니기 때문에 .T() 형태로 사용하지 않습니다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Date 7/1/2016 7/2/2016 7/3/2016 7/4/2016 7/5/2016 7/6/2016 7/6/2016 7/7/2016 NaN 7/9/2016 7/10/2016 7/11/2016 7/12/2016 7/13/2016 7/14/2016 7/15/2016 7/16/2016 7/17/2016 7/18/2016 7/19/2016 7/20/2016 7/21/2016 7/22/2016 7/23/2016 7/24/2016 7/25/2016 7/26/2016 7/27/2016 7/28/2016 7/29/2016 7/30/2016 7/31/2016 Location Park Park Park Beach Beach Beach Beach Beach Beach Beach Beach Beach Beach Beach Beach Beach Beach Beach Park Park Park Park Park Park Park Park Park Park Park Park Beach Beach Lemon 97 98 110 134 159 103 103 143 123 134 140 162 130 109 122 98 81 115 131 122 71 83 112 120 121 156 176 104 96 100 88 76 Orange 67 67 77 99 118 69 69 101 86 95 98 120 95 75 85 62 50 76 92 85 42 50 75 82 82 113 129 68 63 66 57 47 Temperature 70 72 71 76 78 82 82 81 82 80 82 83 84 77 78 75 74 77 81 78 70 77 80 81 82 84 83 80 82 81 82 82 Leaflets 90 90 104 98 135 90 90 135 113 126 131 135 99 99 113 108 90 126 122 113 NaN 90 108 117 117 135 158 99 90 95 81 68 Price 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.35 0.35 0.35 0.35 0.35 0.35 12345678910lemonade.sort_index(axis=0, ascending=True)# .sort_index() 메소드는 행과 열 이름을 정렬해준다.# 정렬 축을 설정할때는 axis를 사용한다# axis=0 : 인덱스를 기준# axis=1 : 컬럼을 기준# ascending은 정렬의 방향을 설정해준다.# ascending=True : 오름차순(기본값)# ascending=False : 내림차순 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 3 7/4/2016 Beach 134 99 76 98.0 0.25 0 4 7/5/2016 Beach 159 118 78 135.0 0.25 0 5 7/6/2016 Beach 103 69 82 90.0 0.25 0 6 7/6/2016 Beach 103 69 82 90.0 0.25 0 7 7/7/2016 Beach 143 101 81 135.0 0.25 0 8 NaN Beach 123 86 82 113.0 0.25 0 9 7/9/2016 Beach 134 95 80 126.0 0.25 0 10 7/10/2016 Beach 140 98 82 131.0 0.25 0 11 7/11/2016 Beach 162 120 83 135.0 0.25 0 12 7/12/2016 Beach 130 95 84 99.0 0.25 0 13 7/13/2016 Beach 109 75 77 99.0 0.25 0 14 7/14/2016 Beach 122 85 78 113.0 0.25 0 15 7/15/2016 Beach 98 62 75 108.0 0.50 0 16 7/16/2016 Beach 81 50 74 90.0 0.50 0 17 7/17/2016 Beach 115 76 77 126.0 0.50 0 18 7/18/2016 Park 131 92 81 122.0 0.50 0 19 7/19/2016 Park 122 85 78 113.0 0.50 0 20 7/20/2016 Park 71 42 70 NaN 0.50 0 21 7/21/2016 Park 83 50 77 90.0 0.50 0 22 7/22/2016 Park 112 75 80 108.0 0.50 0 23 7/23/2016 Park 120 82 81 117.0 0.50 0 24 7/24/2016 Park 121 82 82 117.0 0.50 0 25 7/25/2016 Park 156 113 84 135.0 0.50 0 26 7/26/2016 Park 176 129 83 158.0 0.35 0 27 7/27/2016 Park 104 68 80 99.0 0.35 0 28 7/28/2016 Park 96 63 82 90.0 0.35 0 29 7/29/2016 Park 100 66 81 95.0 0.35 0 30 7/30/2016 Beach 88 57 82 81.0 0.35 0 31 7/31/2016 Beach 76 47 82 68.0 0.35 0 12345lemonade.sort_values(by='Location')# 데이터 프레임의 내부에 있는 값으로 정렬할 수 있다.# 예시의 경우 Location을 기준으로 했다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 15 7/15/2016 Beach 98 62 75 108.0 0.50 17 7/17/2016 Beach 115 76 77 126.0 0.50 16 7/16/2016 Beach 81 50 74 90.0 0.50 30 7/30/2016 Beach 88 57 82 81.0 0.35 14 7/14/2016 Beach 122 85 78 113.0 0.25 13 7/13/2016 Beach 109 75 77 99.0 0.25 12 7/12/2016 Beach 130 95 84 99.0 0.25 11 7/11/2016 Beach 162 120 83 135.0 0.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 31 7/31/2016 Beach 76 47 82 68.0 0.35 8 NaN Beach 123 86 82 113.0 0.25 7 7/7/2016 Beach 143 101 81 135.0 0.25 6 7/6/2016 Beach 103 69 82 90.0 0.25 5 7/6/2016 Beach 103 69 82 90.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 29 7/29/2016 Park 100 66 81 95.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 27 7/27/2016 Park 104 68 80 99.0 0.35 26 7/26/2016 Park 176 129 83 158.0 0.35 25 7/25/2016 Park 156 113 84 135.0 0.50 24 7/24/2016 Park 121 82 82 117.0 0.50 20 7/20/2016 Park 71 42 70 NaN 0.50 22 7/22/2016 Park 112 75 80 108.0 0.50 21 7/21/2016 Park 83 50 77 90.0 0.50 19 7/19/2016 Park 122 85 78 113.0 0.50 18 7/18/2016 Park 131 92 81 122.0 0.50 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 23 7/23/2016 Park 120 82 81 117.0 0.50 0 7/1/2016 Park 97 67 70 90.0 0.25 데이터 추가 삭제하기123lemonade['Sold'] = 0 print(lemonade.head(3))## 'Sold' 라는 기본값 0의 컬럼을 추가한다. Date Location Lemon Orange Temperature Leaflets Price Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 123lemonade['Sold'] = lemonade['Lemon'] + lemonade['Orange']print(lemonade.head(3))# 'Sold에 Lemon과 Orange 의 갯수를 합한 데이터를 넣어준다. Date Location Lemon Orange Temperature Leaflets Price Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 123lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3))# 컬럼을 추가하는 과정을 생략할 수 있다. Date Location Lemon Orange ... Leaflets Price Sold Revenue 0 7/1/2016 Park 97 67 ... 90.0 0.25 164 41.00 1 7/2/2016 Park 98 67 ... 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 ... 104.0 0.25 187 46.75 [3 rows x 9 columns] 123456lemonade_column_drop = lemonade.drop('Sold', axis=1)print(lemonade_column_drop.head(3))lemonade_row_drop = lemonade_column_drop.drop(0, axis=0)print(lemonade_row_drop.head(3))#.drop을 이용해 추가한 컬럼,인덱스를 삭제할 수 있다. Date Location Lemon Orange Temperature Leaflets Price Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 46.75 Date Location Lemon Orange Temperature Leaflets Price Revenue 1 7/2/2016 Park 98 67 72 90.0 0.25 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 46.75 3 7/4/2016 Beach 134 99 76 98.0 0.25 58.25 데이터 인덱싱1print(lemonade[0:5]) Date Location Lemon Orange Temperature Leaflets Price Sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 Revenue 0 41.00 1 41.25 2 46.75 3 58.25 4 69.25 123lemonade['Location'] == 'Beach'# 데이터 프레임에서 로케이션 컬럼 값이 Beach 일경우 True, 아닐경우 False를 반환 0 False 1 False 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 True 14 True 15 True 16 True 17 True 18 False 19 False 20 False 21 False 22 False 23 False 24 False 25 False 26 False 27 False 28 False 29 False 30 True 31 True Name: Location, dtype: bool 12print(lemonade[lemonade['Location'] == 'Beach'].head(5))# 이처럼 자신이 원하는 데이터가 있는 프레임만 찾을 수 있다. Date Location Lemon Orange Temperature Leaflets Price Sold \\ 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 Revenue 3 58.25 4 69.25 5 43.00 6 43.00 7 61.00 12print(lemonade.iloc[0:3, 0:2])# .iloc은 원하는 위치의 데이터를 표시할 수 있다. Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 123print(lemonade.loc[0:2, ['Date','Location']])# .loc는 iloc와 다르게 컬럼명을 직접적으로 설정해줘야한다.# 또한 loc는 지정한 범위 그대로 나온다 Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 1234print(lemonade.loc[lemonade['Revenue']&gt;45, ['Date','Revenue']].head(3))# .loc와 조건문을 결합하여 사용이 가능하다. 이 경우 Revenue 값이 45보다# 큰 데이터프레임에서 Date, Revenue 의 값을 출력한다 라는 의미다 Date Revenue 2 7/3/2016 46.75 3 7/4/2016 58.25 4 7/5/2016 69.25 '\\n.loc와 조건문을 결합하여 사용이 가능하다. 이 경우 Revenue 값이 45보다\\n큰 데이터프레임에서 Date, Revenue 의 값을 출력한다 라는 의미다\\n' 기존 데이터 전처리12print(lemonade.sort_values(by=['Temperature']).head(5))# Temperature 을 기준으로 오름차순 정렬 Date Location Lemon Orange Temperature Leaflets Price Sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 164 20 7/20/2016 Park 71 42 70 NaN 0.50 113 2 7/3/2016 Park 110 77 71 104.0 0.25 187 1 7/2/2016 Park 98 67 72 90.0 0.25 165 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 Revenue 0 41.00 20 56.50 2 46.75 1 41.25 16 65.50 1234567lemonade.sort_values(by=['Temperature', 'Revenue'], ascending= False, inplace = True)print(lemonade.loc[:,['Date','Temperature', 'Revenue']].head(5))# Temperature, Revenue 두 컬럼을 기준으로 했지만 먼저 선언된 Temperature 을 기준# ascending= False 이므로 내림차순 정렬# inplace = True는 테이터프레임의 변경사항을 저장해주는 기능을 한다 Date Temperature Revenue 25 7/25/2016 84 134.50 12 7/12/2016 84 56.25 26 7/26/2016 83 106.75 11 7/11/2016 83 70.50 24 7/24/2016 82 101.50 123print(lemonade.groupby(by='Location').count())# 데이터들을 선언한 변수를 기준으로 그룹화 시켜준다.# 예시의 코드는 Location 컬럼이 포함된 다른 컬럼의 총 갯수를 표현한다. Date Lemon Orange Temperature Leaflets Price Sold Revenue Location Beach 16 17 17 17 17 17 17 17 Park 15 15 15 15 14 15 15 15 12print(lemonade.groupby('Location')['Revenue'].agg([max,min]))# 로케이션 별 최고 최소 수익을 나타내준다. max min Location Beach 95.5 43.0 Park 134.5 41.0 1234import numpy as nplemonade.mean()print(lemonade.groupby('Location')[['Revenue', 'Sold']].agg([max,min,np.mean]))# mean std sum 등 일부 함수는 .agg 안에서 넘파이에서 작성해야 한다. Revenue Sold max min mean max min mean Location Beach 95.5 43.0 58.988235 282 123 201.294118 Park 134.5 41.0 78.546667 305 113 190.333333 결측치12lemonade.isna()# 데이터 프레임의 결측치 값은 True 아닌것은 False로 반환한다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 False False False False False False False False False 12 False False False False False False False False False 26 False False False False False False False False False 11 False False False False False False False False False 24 False False False False False False False False False 10 False False False False False False False False False 28 False False False False False False False False False 8 True False False False False False False False False 30 False False False False False False False False False 31 False False False False False False False False False 5 False False False False False False False False False 6 False False False False False False False False False 18 False False False False False False False False False 23 False False False False False False False False False 7 False False False False False False False False False 29 False False False False False False False False False 22 False False False False False False False False False 27 False False False False False False False False False 9 False False False False False False False False False 19 False False False False False False False False False 4 False False False False False False False False False 14 False False False False False False False False False 17 False False False False False False False False False 21 False False False False False False False False False 13 False False False False False False False False False 3 False False False False False False False False False 15 False False False False False False False False False 16 False False False False False False False False False 1 False False False False False False False False False 2 False False False False False False False False False 20 False False False False False True False False False 0 False False False False False False False False False 1234null_del = lemonade# null_del=null_del.head() : 행 수 줄여서 하는 코딩#인덱스 명 제 코딩 12null_del.dropna()# 셀에 null 값이 하나라도 있을경우 해당 행을 삭제하여 출력한다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 12null_del.dropna(how='all')# 모든 행의 값이 null인 경우만 삭제하여 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 28 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 8 NaN Beach 123 86 82 113.0 0.25 209 52.25 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 29 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 27 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 21 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 20 7/20/2016 Park 71 42 70 NaN 0.50 113 56.50 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 12null_del.fillna(0)# null 값을 전부 0으로 대체해주는 메서드 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 28 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 8 0 Beach 123 86 82 113.0 0.25 209 52.25 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 29 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 27 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 21 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 20 7/20/2016 Park 71 42 70 0.0 0.50 113 56.50 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 1234null_del.fillna({'Date': null_del['Date'].mean()})# 이러한 코드로 넣을 경우 Date 컬럼 값중 null 값은 Date의 평균 값으로 대체된다.# 하지만 오류가 난 것은, 현제 Date값이 정수,실수형이 아닌 # String 타입으로 작성되어 연산이 되지 않기 때문이다. --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-113-b3d91e8536a6&gt; in &lt;module&gt;() ----&gt; 1 null_del.fillna({'Date': null_del['Date'].mean()}) /usr/local/lib/python3.7/dist-packages/pandas/core/generic.py in stat_func(self, axis, skipna, level, numeric_only, **kwargs) 11473 return self._agg_by_level(name, axis=axis, level=level, skipna=skipna) 11474 return self._reduce( &gt; 11475 func, name=name, axis=axis, skipna=skipna, numeric_only=numeric_only 11476 ) 11477 /usr/local/lib/python3.7/dist-packages/pandas/core/series.py in _reduce(self, op, name, axis, skipna, numeric_only, filter_type, **kwds) 4247 ) 4248 with np.errstate(all=&quot;ignore&quot;): -&gt; 4249 return op(delegate, skipna=skipna, **kwds) 4250 4251 def _reindex_indexer(self, new_index, indexer, copy): /usr/local/lib/python3.7/dist-packages/pandas/core/nanops.py in _f(*args, **kwargs) 69 try: 70 with np.errstate(invalid=&quot;ignore&quot;): ---&gt; 71 return f(*args, **kwargs) 72 except ValueError as e: 73 # we want to transform an object array /usr/local/lib/python3.7/dist-packages/pandas/core/nanops.py in f(values, axis, skipna, **kwds) 127 result = alt(values, axis=axis, skipna=skipna, **kwds) 128 else: --&gt; 129 result = alt(values, axis=axis, skipna=skipna, **kwds) 130 131 return result /usr/local/lib/python3.7/dist-packages/pandas/core/nanops.py in nanmean(values, axis, skipna, mask) 561 dtype_count = dtype 562 count = _get_counts(values.shape, mask, axis, dtype=dtype_count) --&gt; 563 the_sum = _ensure_numeric(values.sum(axis, dtype=dtype_sum)) 564 565 if axis is not None and getattr(the_sum, &quot;ndim&quot;, False): /usr/local/lib/python3.7/dist-packages/numpy/core/_methods.py in _sum(a, axis, dtype, out, keepdims, initial, where) 45 def _sum(a, axis=None, dtype=None, out=None, keepdims=False, 46 initial=_NoValue, where=True): ---&gt; 47 return umr_sum(a, axis, dtype, out, keepdims, initial, where) 48 49 def _prod(a, axis=None, dtype=None, out=None, keepdims=False, TypeError: can only concatenate str (not &quot;int&quot;) to str 12null_del.fillna({'Date' : '12/31/2021'})# 이럴 경우 딕셔너리로 칼럼명과 데이터를 넘겨주면 변경이 가능하다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 28 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 8 12/31/2021 Beach 123 86 82 113.0 0.25 209 52.25 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 29 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 27 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 21 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 20 7/20/2016 Park 71 42 70 NaN 0.50 113 56.50 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 123# 결측치를 알맞게 대체 했다면 적용하는 방법이다.null_del# 지금의 데이터는 null 갑이 대체되지 않았다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 28 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 8 NaN Beach 123 86 82 113.0 0.25 209 52.25 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 29 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 27 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 21 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 20 7/20/2016 Park 71 42 70 NaN 0.50 113 56.50 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 1234567null_del.fillna({'Date' : '12/31/2021'},inplace=True)null_del.fillna(method='ffill')# inplace로 변경된 값을 데이터 프레임에 적용해주고, # method 매개변수는 앞에서 뒤의 데이터를 대체해주는 'ffill'# 뒤에서 대체해주는 'backfill 이 있다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 28 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 8 12/31/2021 Beach 123 86 82 113.0 0.25 209 52.25 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 29 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 27 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 21 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 20 7/20/2016 Park 71 42 70 104.0 0.50 113 56.50 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00","link":"/2021/11/02/Pandas/"},{"title":"Statistics-Capter02","text":"1. 교차 분석 교차분석(chi-square test) 이란, 두 개의 변수가 질적인 명목척도일 때, 두 변수간의 빈도 비교를 통해 연관성을 파악하기 위해 사용하는 분석법을 의미한다. 이러한 교차분석을 진행할 때 대립가설과 귀무가설을 설정한다. 귀무가설 : 모집단의 특성에 대해 옳다고 제안하는 잠정적인 가설 대립가설 : 귀무가설이 거짓일 경우 대안적으로 참이 되는 가설 이러한 교차분석을 설명하기 위해 알아야 하는 것은 카이제곱 값과 유의확률 이다. 카이제곱 값은 χ2 = Σ (관측값 - 기댓값)2 / 기댓값 으로 표현한다. 유의확률(p)은 귀무 가설이 맞다고 가정했을 때 얻은 결과보다 극단적인 결과가 실제로 관측될 확률을 뜻한다. 통상적으로 유의 확률은 0.05, 0.01을 기준으로 하는것이 관례이며 기준보다 낮은 값이 나올경우 유의미 라고 표현한다. 이러한 교차 분석을 설명하기 위해 SPSS에서 예시를 들어 설명하겠다. 2. SPSS 교차 분석 예시 변수 설정 교차분석의 경우 독립변수와 종속변수의 구분이 없다.1변수 : 성별, 연령대 가설 설립 12귀무가설 : 성별과 연령대는 연관성이 없다대립가설 : 성별과 연령대는 연관성이 있다. SPSS 실행 결과 해석 위 사진으로 보면 10대~40대까지 연령대를 나눠서 총 15케이스를 교차분석한 결과 카이제곱 값은 2.277, 유의확률은 0.517이 나왔다. 이러한 경우 유의확률 기준치인 0.05보다 크기 때문에 대립가설을 기각하고 귀무가설을 체택한다. 결론 : 성별과 연령대는 연관성이 없다","link":"/2021/11/02/Statistics-Capter02/"},{"title":"Colab-github","text":"1. 구글 Colab에서 작성한 파일 github blog에 업로드 하기 Colab에서 파일 저장하기 goolge colab에서 깃헙 블로그에 파일을 저장하기 위해선 먼저 colab에서 파일을 .ipynb 형식으로 파일을 다운로드 해준다. Anaconda 실행 Anaconda Navigator을 관리자 권한으로 실행 JupyterLab Lunch 클릭해서 쥬피터랩을 실행한다. 쥬피터랩에서 colab에서 작성한 .ipynb 형식의 파일을 찾아 클릭한다. 위 화면처럼 .ipynb 형식 파일을 Markdown 파일 형식으로 저장한다. 쥬피터랩에서 다운받은 .md 파일을 블로그 폴더 source - _post 폴더에 넣고 파이참으로 파일을 연다. hexo server 로 파일이 제대로 불러와지는지 확인하고 오류가 없다면 hexo generate hexo deploy를 실행한다.","link":"/2021/11/02/Colab-github/"},{"title":"github-blog","text":"1. node.js 설치1. node.js 설치 클릭 설치할때 path 경로를 설정을 꼭 해줘야한다. 2.git bash에서 node설치 확인 git bash 실행 입력창에 node -v 입력 버전이 확인되었다면 npm install -g hexo-cli 입력 2. 블로그 파일 설정1. 원하는 경로에 git bash를 이용해 폴더를 새로 만든다. hexo init foldername 입력 폴더가 생성되었다면 hexo 서버 연결을 위한 설정을 파이참으로 해준다 npm install npm install hexo-server --save npm install hexo-deployer-git --save2. git hub 사이트에 새로운 파일은 리퍼지토리 한다. 설정한 폴더명으로 리퍼지토리를 진행한다. echo &quot;# dsadsa&quot; &gt;&gt; README.md, git init 까지 입력하고 git add . 후 나머지를 작성해준다. 리퍼지토리가 제대로 이루어졌는지 확인한다. 3. github.io 파일 설정1. git hub에서 username.github.io로 새로운 파일을 리퍼지토리 해준다 _config.yml 폴더에서 설정을 진행 _config.yml에서 title 은 블로그의 제목을 설정 url 에서는 https://username.github.io으로 url값을 설정 이때 https://로 설정하지 않을 경우 `hexo deploy` 를 했을 때 404오류가 발생 할 수 있다. # Deployment 아래의 코드를 입력한다. deploy: type: git repo: https://github.com/rain0430/rain0430.github.io.git branch: main 2. github에 배포하기 git bash 에 hexo generate hexo server 입력 hexo server 입력 후 터미널에 localhost:4000를 클릭하여 블로그가 정상적으로 출력되는지 확인한다. 확인후 control + c를 눌러 서버를 종료한 후, hexo deploy 를 입력한다. 본인이 설정한(usernaem,github.io)를 주소창에 입력하여 정상작동을 확인한다. 블로그가 작성되는 시간이 있기 때문에 1분 정도 404 오류가 뜰 수 있다. 4. 블로그 테마 적용하기1. 블로그 테마 선택하기 블로그 테마에는 다양한 종류가 있으며 git hub를 확인하여 업데이트가 최신으로 이루어지는 테마를 선택하는 것이 좋다. 그 중 예시로 icarus의 설치를 해보겠다. 2. 블로그 테마 설치하기 터미널에 npm install -S hexo-theme-icarus 입력하여 icarus 설치 _config.yml 에서 theme: landscape 부분을 주석 처리후 theme: icarus 입력 그 후 hexo generate 와 hexo server를 실행하면 에러가 발생하는 것을 볼 수 있다. 터미널에 npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 을 입력하고 다시 실행 로컬에서 테마가 정상 작동하는 것을 확인하고 hexo deploy를 진행해 준다. 추가 정보는 고든의 깃허브에서 확인 가능하다. 이건 귀여운 고양이 사진이다","link":"/2021/11/02/github-blog/"},{"title":"Statistics-Capter03","text":"1. 피어슨 상관분석 피어슨(Pearson) 상관 분석(correlation analysis) 이란 다른 용어로 선형상관분석을 줄인 단어로 두 변수간의 어떤 선형적 또는 비선형적 관계를 갖고 있는지 분석하는 방법이다. 선형이란 두 변수 사이의 밀접성, 강도, 방향을 요약하여 나타내는 수치로,-1 &lt;= r &lt;=1 의 값을 가지는데, 이때 두 변수간의 상관관계(r)가 0이면, 이것은 ‘두 변수간의 상관이 없다는 뜻이 아닌 선형관계가 아니다’ 라는 뜻이다. 선형 그래프는 크게 3가지 종류로 나누어진다 이러한 특징은 다른 의미로 상관 분석은 변수간의 인과관계를 파악하는데 사용하는 것은 잘못되었음을 의미한다. 이러한 피어슨 상관분석을 설명하기 위해 SPSS에서 예시를 들어 설명하겠다. 2. 피어슨 상관분석 예시 변수 설정1변수 : 폭력, 공감, 정서, 심리 가설 설립 피어슨 상관분석은 단순히 두 변수간의 상관관계 유무와 정도를 파악할 뿐, 인과관계를 파악하는 것이 아니므로 가설을 따로 설립하지 않는다. SPSS 실행 결과 해석 위의 표에서 Pearson 상관의 값을 보면 음수와 양수로 나눠져 있음을 볼 수 있다.두 변수간의 부호가 +, 양수라면 두 변수가 정적 상관관계(우상향 선형)을 가지고 있음을 의미하며, 음수라면 부적 상관관계(우하향 선형) 형태임을 뜻한다. 표의 결과를 보면 공감과 심리간의 상관 관계에서 r=0.899, p=0.000 으로 가장 높은 정적 상관관계를 나타내고 있으며,정서와 심리는 r=0.605, p=0.000으로 상대적으로 낮은 정적 상관관계를 보여주고 있다.- 폭력과 공감은 r=-0.295, p=0.000으로 가장 높은 부적 상관관계를 보이며, 폭력과 정서는r=-0.243 으로 상대적으로 낮다. 피어슨 상관분석은 이처럼 두 변수간의 관계의 유무를 나타낼 뿐이고, 이와 관련된 인과관계를 파악하기 위해서는 회귀분석을 이용 할 수 있다.","link":"/2021/11/02/Statistics-Capter03/"},{"title":"Statistics-Capter01","text":"변수(Variable) 란, 연구자가 연구하고자 하는 개념을 뜻한다. ex)성별 나이 학벌 수면 시간 등.. 변수는 위치와 역활에 따라 크게 독립변수, 종속변수, 제3변수로 개념이 나눠진다. 독립변수(Independent Variable)이란 어떤 현상에 원인의 역할을 하는 변수를 의미한다. 종속변수((Dependent Variable)이란 원인에 의해 결과가 달라지는 변수를 의미한다. 2. 척도의 개념 척도(Scale)이란 변수를 측정 가능토록 수치화한 것 을 의미한다. 척도는 크게 명목척도, 등간척도, 서열척도, 비율척도가 있다. 측정 수준 척도 성질 예시 연산 분류 명목척도 (Nominal scale) 고유함 이름, 성별 비가산 집합 서열척도 (ordinal scale) 순서 순위, 서열 비가산 집합 수량 등간척도 (interval scale) 순서, 간격 온도, 지능지수 사칙연산 중 가산가능 비율척도 (Ratio scale) 순서, 간격, 비율 자연수, 몸무게 사칙연산 가능 분석을 진행할 때 독립변수와 종속변수가 각각 어떠한 척도로 구성되어 있는지에 따라 다른 분석법이 사용된다. 그럼으로 분석을 진행하기 전, 변수가 어떠한 척도로 구성되어 있는지 반드시 확인해야만 한다.","link":"/2021/11/02/Statistics-Capter01/"},{"title":"Python 문법 1","text":"Hello World1print(&quot;Hello World&quot;) Hello World 주석처리123456# 한 줄 주석처리 할때는 #을 붙인다&quot;&quot;&quot;여러 줄을 주석처리 할 때는 큰 따옴표 or 작은 따옴표 세게 사이에 사용한다. 줄의 수는 상관이 없다&quot;&quot;&quot;print(&quot;주석처리&quot;) 주석처리 #변수의 종류 1234567891011num_int = 1print(type(num_int))num_float = 0.2print(type(num_float))bool_true = Trueprint(type(bool_true))none_x = Noneprint(type(none_x)) &lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'NoneType'&gt; 사칙 연산123456789a = 5b = 4print('a + b = ', a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b) a + b = 9 a - b = 1 a * b = 20 a / b = 1.25 a // b = 1 a % b = 1 a ** b = 625 123456789c = 4.0d = 6.0print('c + d =', c+d)print('c - d =', c-d)print('c * d =', c*d)print('c / d =', c/d)print('c // d =', c//d)print('c % d =', c%d)print('c ** d =', c**d) c + d = 10.0 c - d = -2.0 c * d = 24.0 c / d = 0.6666666666666666 c // d = 0.0 c % d = 4.0 c ** d = 4096.0 문자열과 정수열 연산12345678# 문자열에 숫자를 더하기 위해선 어떻게 해야할까?a = 1004b = &quot;천사&quot;c = a+bprint(c)#위의 결과처럼 문자열과 숫자를 단순히 연산자로 더해줄 경우 오류가 발생한다 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-108-fe25ce2f05b3&gt; in &lt;module&gt;() 2 a = 1004 3 b = &quot;천사&quot; ----&gt; 4 c = a+b 5 6 print(c) TypeError: unsupported operand type(s) for +: 'int' and 'str' 1234567# 이 문제를 해결하기 위해선 숫자(정수형, 실수형)을 문자형으로 바꿔줄 필요가 있다.a = str(1004) #정수 1004를 str()로 묶어 문자형으로 변형해주었다.b = &quot;천사&quot;c = a+bprint(c) 1004천사 1234567# 그렇다면 + 가 아닌 다른 연산자인 * 를 사용하면 어떻게 될까?a = str(1004)b = &quot;천사&quot;c = a*bprint(c) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-110-b55996f7f08d&gt; in &lt;module&gt;() 3 a = str(1004) 4 b = &quot;천사&quot; ----&gt; 5 c = a*b 6 7 print(c) TypeError: can't multiply sequence by non-int of type 'str' 123456789101112# 위의 결과처럼 오류가 뜨지만, 이것이 문자형에 * 연산자를 사용하지 못함을 의미하는 것은 아니다.a = str(1004)b = &quot;천사&quot;c = a+bprint(b*3)# 위 결과처럼 &quot;천사&quot; 을 * 연산자를 사용해 3번 출력이 가능한 것을 확인 할 수 있다.#응용print((c+b)*3)#이런식으로 복합 연산도 가능하다. 천사천사천사 1004천사천사1004천사천사1004천사천사 논리형 연산자1234print(True and True)print(True and False)print(False and True)print(False and False) True False False False 1234print(True or True)print(True or False)print(False or True)print(False or False) True True True False 비교 연산자123456print(4 &gt; 3)print(4 &lt; 3)print(4 &gt;= 3)print(4 &lt;= 3)print(4 &gt; 4)print(4 &gt;= 4) True False True False False True 논리형 &amp; 비교 연산자 응용1234# input(&quot;숫자를 입력하세요&quot;)data = input(&quot;숫자를 입력하세요&quot;)data2 = int(data)print(type(data2)) 숫자를 입력하세요100 &lt;class 'int'&gt; 12345678num1 = int(input(&quot;첫번째 숫자를 입력하세요: &quot;))num2 = int(input(&quot;두번째 숫자를 입력하세요: &quot;))num3 = int(input(&quot;세번째 숫자를 입력하세요: &quot;))num4 = int(input(&quot;네번째 숫자를 입력하세요: &quot;))var1 = num1 &gt;= num2var2 = num3 &lt; num4print(var1 and var2) 첫번째 숫자를 입력하세요: 5 두번째 숫자를 입력하세요: 4 세번째 숫자를 입력하세요: 3 네번째 숫자를 입력하세요: 2 False String12print(&quot;'Hello, world!'&quot;)print('&quot;Hello, world!&quot;') String Operators123str1 = &quot;Hello &quot;str2 = &quot;World &quot;print('str1 + str2 = ', str1 + str2) str1 + str2 = Hello World 12greet = str1 + str2print('greet * 3 = ', greet * 3) greet * 3 = Hello World Hello World Hello World Indexing12greeting = &quot;Hello Kaggle&quot;print(greeting[6]) Slicing 123456greeting = &quot;Hello Kaggle&quot;print(greeting[:])print(greeting[6:])print(greeting[:6])print(greeting[3:8])print(greeting[0:9:2]) Hello Kaggle Kaggle Hello lo Ka HloKg 1234greeting[13]&quot;&quot;&quot;정해진 문자열 보다 더 큰 배열값이 들어갔기 때문에 null값이 출력되어야 하기 때문에 오류가 나온다&quot;&quot;&quot; --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-16-e484aa72e855&gt; in &lt;module&gt;() ----&gt; 1 greeting[13] 2 &quot;&quot;&quot; 3 정해진 문자열 보다 더 큰 배열값이 들어갔기 때문에 null값이 출력되어야 하기 때문에 오류가 나온다 4 &quot;&quot;&quot; IndexError: string index out of range 리스트1234567891011121314e = [['apple','banana','cherry'],1]print(e[0][2])a = [] # 빈 리스트a_func = list() #list()함수로도 빈 리스트를 만들 수 있다.b = [1] # 숫자도 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다d = [1, 2, ['apple']] # 리스트 안에 리스트를 요소로 넣을 수 있다.print(a)print(a_func)print(b)print(c)print(d) cherry [] [] [1] ['apple'] [1, 2, ['apple']] 123456a = [1, 2, 3]# index [[0], [1], [2]]print(a[0]) # 첫번째 요소print(a[1]) # 두번째 요소print(a[2]) # 세번째 요소print(a[-1]) 1 2 3 3 123456a = [['apple','banana','cherry']]print(a[0]) # 리스트 내의 리스트print(a[0][0]) # 리스트 내의 리스트의 첫번째 문자열print(a[0][0][3]) # 리스트 내의 리스트의 첫번째 문자열 'apple' 중 첫번째 인덱스print(a[0][1]) # 리스트 내의 리스트의 두번째 문자열 ['apple', 'banana', 'cherry'] apple l banana 12345678910111213a = [1,2,3,4,5,6,7,8,9,10]b = a[:4] # 인덱스 0부터 3까지c = a[1:4] # 인덱스 1부터 3까지d = a[0:7:2] # 인덱스 0부터 6까지 인덱스 2씩 건너 띄우기e = a[::-1] # 리스트 a의 역순f = a[::2] # 리스트 전체구간에서 인덱스 2씩 건너띄우기print(&quot;a[:4]&quot;, b)print(&quot;a[1:4]&quot;, c)print(&quot;a[0:7:2]&quot;, d)print(&quot;a[::-1]&quot;, e)print(&quot;a[::2]&quot;, f) a[:4] [1, 2, 3, 4] a[1:4] [2, 3, 4] a[0:7:2] [1, 3, 5, 7] a[::-1] [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] a[::2] [1, 3, 5, 7, 9] 12345a = ['alice', 'bob', 'cat']b = ['apple', 'banana', 'cherry']c = a+bprint(c) ['alice', 'bob', 'cat', 'apple', 'banana', 'cherry'] 123456a = ['a','b','c']b = a*3c = a*0print(&quot;a * 3:&quot;, b)print(&quot;a * 0:&quot;, c) a * 3: ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c'] a * 0: [] '\\n문제에서 제공된 수의 범위를 보면 5부터 -9 까지 -2 씩 줄어드는 걸 알 수 있다. \\nlist에서 range 메소드를 이용할 경우 ()안에 각각 값의 의미는 ((a,b,c) 일 경우 a=시작 숫자/b=끝 숫자/c= 숫자들의 증감폭) 이다.\\n' 리스트 도장 연습문제 range를 이용해 [5, 3, 1, -1, -3, -5, -7, -9]가 출력되게 만드세요 12345678a = list(range(5,-10,-2))print(a)&quot;&quot;&quot;문제에서 제공된 수의 범위를 보면 5부터 -9 까지 -2 씩 줄어드는 걸 알 수 있다. list에서 range 메소드를 이용할 경우 ()안에 각각 값의 의미는 ((a,b,c) 일 경우 a=시작 숫자/b=끝 숫자/c= 숫자들의 증감폭) 이다.&quot;&quot;&quot; [5, 3, 1, -1, -3, -5, -7, -9] '\\n문제에서 제공된 수의 범위를 보면 5부터 -9 까지 -2 씩 줄어드는 걸 알 수 있다. \\nlist에서 range 메소드를 이용할 경우 ()안에 각각 값의 의미는 ((a,b,c) 일 경우 a=시작 숫자/b=끝 숫자/c= 숫자들의 증감폭) 이다.\\n' 리스트 값 추가하기1234a = [0,1,2]a[1] = &quot;b&quot;# a의 배열값 1을 &quot;b&quot;로 바꿔준다print(a) [0, 'b', 2] 리스트값 추가하기1234567a = [100, 200, 300]a.append(400)print(a)# 맨처음 a 배열에 400을 뒤에 추가로 넣어준다.a.append([500,600])print(a)# 400이 추가된 배열에 또 추가로 [500,600] 의 배열을 추가로 넣어준다. [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]] 12345a = [1,2,3]a.extend([40,500])print('a.extend([40,500]) result')print(a) #append와 다르게 추가를 배열로 넣어줬지만, extend는 배열과 배열을 합쳐주는 거기 때문에 하나의 배열로 합쳐져 출력된다. a.extend([40,500]) result [1, 2, 3, 40, 500] 123456a = [0,1,2]a.insert(4,5)a.insert(4,&quot;HI&quot;)print(a)# insert에서 ()안에서 앞의 숫자는 배열의 순서를 지정해주고, 뒤의 숫자는 배열에 들어갈 값을 의미한다. [0, 1, 2, 5, 'HI'] 1234567891011121314a = [0,1,2,3]a[0:0] = [100,200]print(a)# 시작과 끝의 범위보다 큰 수를 덮어쓰는 예시b = [0,1,2,3]b[1:1] = [100,200,300,400] print(b)# 시작과 끝의 범위가 작을때의 예시c = [0,1,2,3]b[1:2] = [100,200,300,400] print(c)# 잘 사용하지 않는다. [100, 200, 0, 1, 2, 3] [0, 100, 200, 300, 400, 1, 2, 3] [0, 1, 2, 3] 리스트 값 삭제하기12345678910a =[1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a)#리스트의 두번째 1이 삭제a.remove(1)print(a)# remove를 이용하면 배열에 순서대로 삭제가 가능하다. 이때, 배열에 존재하지 않는 값을 넣을 경우 오류가 발생한다. [2, 1, 2] [2, 2] 12345678910a = [0,4,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)# del은 배열에 위치를 지정해서 삭제가 가능하다.b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 index부터, 종료하는 n의 n-1까지의 범위를 잡아줍니다.print(b) [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9] 123456#인덱스를 지정한 pop()a = [1,1,2,3,4]r = a.pop(0)# 윈도우의 잘라서 붙여넣기를 생각하면 쉽다.print(a)print(r) [1, 2, 3, 4] 1 123456#인덱스를 지정하지 않은 pop()b = ['a','b','c','d',]x = b.pop()# 인덱스를 지정하지 않을 경우 배열의 가장 끝의 값을 가져온다.print(b)print(x) ['a', 'b', 'c'] d 그 외 유용한 메서드12345a = [0,1,2,3]print(a)# 배열의 모든 값을 삭제하는 메서드a.clear()print(a) [0, 1, 2, 3] [] 123a = [&quot;Gold&quot;, &quot;Gold&quot;, &quot;Silver&quot;, &quot;Silver&quot;]print(&quot;Silver가 처음 등장하는 인덱스 번호&quot;, a.index(&quot;Silver&quot;))# 해당 값이 들어있는 배열의 번호를 출력하는 메서드 Silver가 처음 등장하는 인덱스 번호 2 12345678910a = [1, 4, 5, 2, 3]b = ['a', 'c','f','b','d','e']a.sort()print(&quot;sort():&quot;,a)# 무작위로 나열된 배열의 값을 내림차순으로 정렬하는 메서드b.sort(reverse=True)print(&quot;sort(reverse=True):&quot;, b)# 무작위로 나열된 배열의 값을 오름차순으로 정렬하는 메서드# 알파벳 순서도 가능하다. sort(): [1, 2, 3, 4, 5] sort(reverse=True): ['f', 'e', 'd', 'c', 'b', 'a'] 12345b = [4,3,2,'a']b.sort()print(b)# 단, 문자열과 정수를 혼합해서 정렬하는것은 불가능하다. --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-71-1624da3f09a9&gt; in &lt;module&gt;() 1 b = [4,3,2,'a'] 2 ----&gt; 3 b.sort() 4 print(b) TypeError: '&lt;' not supported between instances of 'str' and 'int' 튜플1234567891011tuple1 = (0) # 끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) # 끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) # 콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) # 콤마(,)를 붙여주어야 튜플 자료형 입니다.print(type(tuple3)) # 여러개의 값 일경우 괄호를 없애주어도 튜플 자료형 입니다. 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 12a = (0,1,2,3,'a')del a[1] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-74-e9d08d739f62&gt; in &lt;module&gt;() 1 a = (0,1,2,3,'a') ----&gt; 2 del a[1] TypeError: 'tuple' object doesn't support item deletion 12a = (0,1,2,3,'a')a[1]='t' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-75-04fb068f82e0&gt; in &lt;module&gt;() 1 a = (0,1,2,3,'a') ----&gt; 2 a[1]='t' TypeError: 'tuple' object does not support item assignment 튜플은 리스트처럼 요소를 저장할 수 있지만, 리스트와 다르게 요소를 추가, 삭제, 변경 할 수 없다 튜플 인덱싱 및 슬라이싱 하기1234t = (0,1,2,'b',4)print(t[1])print(t[3]) 1 b 1234t = (0,1,2,3,4)print(t[2:]) #시작만 설정할 경우 시작 순서부터 배열 끝까지 값을 가져온다.print(t[0:2]) #시작과 끝을 지정할 경우 리스트와 마찬가지로 끝 지점은 설정 한 값보다 하나 작게 출력된다. (2, 3, 4) (0, 1) 튜플의 더하기 및 곱셈 연산자 사용123456t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1+t2print(t1+t2)print(t3)#튜플의 요소를 삭제, 추가, 변경은 불가능하지만, 튜플과 튜플을 합치는 것은 가능하다. (0, 1, 2, 3, 4, 'a', 'b', 'c') (0, 1, 2, 3, 4, 'a', 'b', 'c') 1234t1 = ('a',1)print(t1*0)print(t1*3)# 튜플에 지정된 요소에 곱하기를 하는 것이 아닌, 요소 자체의 갯수를 늘려준다. () ('a', 1, 'a', 1, 'a', 1) 딕셔너리1234567dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list'])# 값을 : 을 통해 서로 연관하여 만든다 alice 5 [1, 2, 3] 1234dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['real'])# 따로 지정해주지 않으면 나오지 않는다. --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-82-4c77a57c3172&gt; in &lt;module&gt;() 1 dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]} ----&gt; 2 print(dic['real']) 3 4 # 따로 지정해주지 않으면 나오지 않는다. KeyError: 'real' 1234a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.keys()# keys() 를 사용하면 연관지은 변수 명을 호출한다. dict_keys(['name', 'job', 'age']) 123a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.values()# values() 를 사용하면 연관지어진 변수를 호출한다. dict_values(['bob', 'farmer', 35]) 1234a = {'name': 'chris', 'job': 'painter', 'age': 30}print(a.get('name')) # 일반적인 딕셔너리로 연관지어진 값을 가져온다.print(a.get('dinner')) # 따로 지정해주지 않았음으로 null값이기 때문에 None이 나온다print(a.get('dinner', 'empty')) # 두 변수 모두 따로 지정해주지 않았지만, 첫번째 선언한 dinner가 null이기 때문에 뒤에 선언한 변수가 추가로 출력된다 chris None empty 집합 연산자12345678s = {}print(type(s))s = set()print(type(s))s = {1,2,3}print(type(s)) &lt;class 'dict'&gt; &lt;class 'set'&gt; &lt;class 'set'&gt; 12345678a = {1,3,5}b = {2,4,6}c = a|bd = a.union(b)print(&quot;a|b:&quot;, c)print(&quot;a.union(b)&quot;, d)# 두 집합을 합쳐주는 방법 a|b: {1, 2, 3, 4, 5, 6} a.union(b) {1, 2, 3, 4, 5, 6} 123456789101112a = {1,3,5}b = {2,4,6}c = a&amp;bprint(c)e = {1,2,5}f = {2,3,5}g1 = e&amp;fg2 = e.intersection(f)print(&quot;e&amp;f:&quot;, g1)print(&quot;e.intersection(f):&quot;, g2)# 두 집합의 교집합을 출력하는 방법 12345678a = {1,3,5}b = {2,4,5}c1 = a-bc2 = a.difference(b)print(&quot;a-b:&quot;, c1)print(&quot;a.difference(b)&quot;, c2)# a와 b의 교집합을 제외하고난 a 집합의 값만 출력하는 방법 12345678a = {1,2,3,4,5}b = {3,4,5,6,7}c1 = a^bc2 = a.symmetric_difference(b)print(&quot;a^b&quot;, c1)print(&quot;a.symmetric_difference(b)&quot;, c2)# a와 b집합의 차집합을 출력하는 방법 if 조건문12345678910a = 1if a&gt;5: print('a is bigger than 5')elif a &gt; 0: print(&quot;a is bigger than 0 but a is smaller than 5 &quot;)else: print(&quot;a is negative&quot;) a is bigger than 0 but a is smaller than 5 1234567x = 10 if x == 10: print('x에 들어있는 숫자는') print('10입니다.') # unexpected indent 에러 발생 #파이썬의 경우 들여쓰기가 문법으로 설정되어 있다. 위 코드의 경우 코드의 경우 들여쓰기 오류가 발생한 것이다. File &quot;&lt;ipython-input-114-3d11f098459b&gt;&quot;, line 5 print('10입니다.') # unexpected indent 에러 발생 ^ IndentationError: unexpected indent 123456789101112x = 10 if x == 10: print('x에 들어있는 숫자는') #들여쓰기 4칸 print('10입니다.') &quot;&quot;&quot;이처럼 파이썬의 if문 문법의 기본 형태는if a == n; print(dsadasd)형식으로 if 문 다음 줄은 4칸의 들여쓰기를 해야한다.다른 의미로는 : 로 끝나고 난 다음 줄은 반드시 들여쓰기를 해야한다.&quot;&quot;&quot; x에 들어있는 숫자는 10입니다. '\\n이처럼 파이썬의 if문 문법의 기본 형태는\\nif a == n;\\n print(dsadasd)\\n형식으로 if 문 다음 줄은 4칸의 들여쓰기를 해야한다.\\n다른 의미로는 : 로 끝나고 난 다음 줄은 반드시 들여쓰기를 해야한다.\\n' 반복문12for i in range(10): print(&quot;Hello World&quot;) Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World 123456789a = &quot;Kaggle&quot;for x in a: print(x) if x == 'g': break #a에 들어간 Kaggle에서 g의 순서가 나올때까지 반복해서 g가 나올경우 g를 x에 넣고 출력한다. K a g 12345alphabets = ['A', 'B', 'C']for index, value in enumerate(alphabets): # 시퀀스 자료형이 들어간다 print(index, value) # 알파벳 벨류에 들어간 배열이 끝날때 까지 전부 출력한다. 0 A 1 B 2 C","link":"/2021/11/02/Python01/"},{"title":"numpy 기초문법","text":"numpy 기초12import numpy as np 12data1 = [1,2,3,4,5]data1 [1, 2, 3, 4, 5] 12data2 = [1,2,3,4,5]data2 [1, 2, 3, 4, 5] 12arr1 = np.array(data1)arr1 array([1, 2, 3, 4, 5]) 12arr1.shape# 넘파이의 배열의 길이를 튜플 형식으로 나타내준다. (5,) 12arr1.dtype# 넘파이 배열의 값의 자료형을 나타내준다. dtype('int64') 123arr2 = np.array([1,2,3,4,5]) arr2# 1차원 데이터 array([1, 2, 3, 4, 5]) 12arr3 = np.array(data2)arr3 array([1, 2, 3, 4, 5]) 1234arr4 = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])arr4# 2차원 데이터 array([[ 1, 2, 3], [ 4, 5, 6], [ 7, 8, 9], [10, 11, 12]]) 1arr4.shape (4, 3) 123array5 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])array5.shape# 3차원 데이터 (2, 2, 2) 넘파이 기본 함수12np.arange(10)# 배열을 생성하는 함수, 지정해준 값-1 까지 배열을 생성해준다. array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1234np.arange(3,10)# 범위를 지정 할 수 있다.np.arange(0,10,2)# 범위를 지정해 주고 동시에 배열값의 증감폭도 지정해 줄 수 있다. array([0, 2, 4, 6, 8]) 12np.zeros(10)# 값이 0으로 이루어진 배열을 생성한다. array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 12np.ones(9)# 값이 1로 이루어진 배열을 생성한다. array([1., 1., 1., 1., 1., 1., 1., 1., 1.]) reshape1234ones_array = np.ones((3,4), dtype='int32')print(ones_array)print(&quot;Data Type is:&quot;, ones_array.dtype)print(&quot;Data Shape is:&quot;, ones_array.shape) [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Type is: int32 Data Shape is: (3, 4) 1234after_reshape = ones_array.reshape(6,2)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape)# 배열의 형태를 변형해줄 수 있다. [[1 1] [1 1] [1 1] [1 1] [1 1] [1 1]] Data Shape is: (6, 2) 123after_reshape = ones_array.reshape(5,3)# cannot reshape array of size 12 into shape (5,3)# 이 뜻은 원래 배열의 값(12) 보다 더 크게 배열을 만들 수 없을을 뜻한다. --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-25-94cac763be50&gt; in &lt;module&gt;() ----&gt; 1 after_reshape = ones_array.reshape(5,3) ValueError: cannot reshape array of size 12 into shape (5,3) 1234after_reshape = ones_array.reshape(2,3,2)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape)# 2차원 3x4 배열을 3차원 2x3x2의 형태로 만들어 줄 수 있다. [[[1 1] [1 1] [1 1]] [[1 1] [1 1] [1 1]]] Data Shape is: (2, 3, 2) 1234after_reshape2= ones_array.reshape(-1,6)print(&quot;reshape(-1,6)? \\n&quot;)print(after_reshape2)# 배열을 바꿔줄때, 앞에 -1을 넣을 경우 자동으로 뒤의 숫자에 맞춰 리쉐이프를 진행해준다 reshape(-1,6)? [[1 1 1 1 1 1] [1 1 1 1 1 1]] Array 연산 Array연산은 기본적으로 크기가 서로 동일해야 진행된다. 이때 같은 위치에 있는 요소들 끼리 연산된다. 123arr1 = np.array([[1,2,3],[4,5,6]])arr1 array([[1, 2, 3], [4, 5, 6]]) 1234arr2 = np.array([[10,11,12],[13,14,15]])arr2 array([[10, 11, 12], [13, 14, 15]]) 1arr1 + arr2 array([[11, 13, 15], [17, 19, 21]]) 1arr1 - arr2 array([[-9, -9, -9], [-9, -9, -9]]) 12arr1 * arr2# 행렬의 곱셉처럼 진행되는게 아닌, 각 요소별로 곱셈이 진행된다. array([[10, 22, 36], [52, 70, 90]]) 1arr1 / arr2 array([[0.1 , 0.18181818, 0.25 ], [0.30769231, 0.35714286, 0.4 ]]) Array 브로드 캐스트 브로드캐스트란, 서로 크기가 다른 Array의 연산을 가능캐하는 것 이다. 12arr1 array([[1, 2, 3], [4, 5, 6]]) 12345arr3 = np.array([10,11,12])arr3 array([10, 11, 12]) 12arr1 + arr3# 이 결과처럼 arr1에 arr3이 각각 더해진다. array([[11, 13, 15], [14, 16, 18]]) 1arr1 * arr3 array([[10, 22, 36], [40, 55, 72]]) 그 외 연산1arr1 * 10 array([[10, 20, 30], [40, 50, 60]]) 12arr1 ** 2# 요소값에 제곱 array([[ 1, 4, 9], [16, 25, 36]]) Array boolean 인덱싱(마스크) Array의 다차원 인덱싱을 응용하여 boolean 인덱싱을 할 수 있다. 이러한 방법을 마스크라고 이야기한다 마스크처럼 원하는 요소만을 꺼낼 수 있다. 1234names = np.array(['A','B','C','D','E','F','G','H'])names array(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'], dtype='&lt;U1') 123456data = np.random.randn(8,4)data#.random.randn 기대값 0 표준편차가 1인 난수를 발생시켜주는 함수다 array([[-0.78574336, 0.48987839, 0.82645617, -0.17152028], [-0.3937686 , -0.93822294, 2.14477087, 0.14940101], [ 1.43828557, 0.47514969, -0.08924484, -0.96863949], [ 0.38315778, 0.52111372, 0.05168264, -0.73003927], [ 1.22600484, -0.31477497, -0.70510052, -1.42081814], [-0.76256766, 0.61905043, -0.42352021, 1.8825546 ], [ 0.72534189, -2.13280186, 0.72306828, 1.18772154], [ 1.31611304, 0.98261818, 0.38594941, -0.25431404]]) names 와 data라는 두 array이가 있을때, 각 요소의 행이 연결되었고names가 A 인 행의 data를 본다고 하면 아래와 같이 해야한다. 1234# 요소가 A인 항목에 대한 mask 생성names_A_mask = (names == 'A')names_A_mask array([ True, False, False, False, False, False, False, False]) 1data[names_A_mask,:] array([[-0.78574336, 0.48987839, 0.82645617, -0.17152028]]) 위의 값을 본다면 0행의 값이 A인 것을 알 수 있다. 12data[names == 'B',:]# 요소가 B인 행의 데이터만 꺼내기 array([[-0.3937686 , -0.93822294, 2.14477087, 0.14940101]]) 123data[(names == 'C') | (names == 'D'),:]#논리값을 이용해 C 또는 D인 행의 데이터만 꺼내기 array([[ 1.43828557, 0.47514969, -0.08924484, -0.96863949], [ 0.38315778, 0.52111372, 0.05168264, -0.73003927]]) data array 자체적으로도 마스크를 만들고 응용이 가능하다.0번째 열이 0보다 작은 행을 구한다면 어떻게 해야할까? 12data[:,0] &lt; 0#먼저 data array에서 0번째 열이 0보다 작은 요소의 값은 다음과 같다. array([ True, True, False, False, False, True, False, False]) 12data[data[:,0]&lt;0,:]#위에서 만든 마스크를 이용해 0번째 열의 값이 0보다 작은 행을 구한다. array([[-0.78574336, 0.48987839, 0.82645617, -0.17152028], [-0.3937686 , -0.93822294, 2.14477087, 0.14940101], [-0.76256766, 0.61905043, -0.42352021, 1.8825546 ]]) 123data[data[:,0]&lt;0,2:4]#이걸 응용하면 특정위치에 값을 대입할 수 있다.#위의 코드는 0번째 열의 값이 0보다 작은 행의 2.3번째 열값이다. array([[ 0.82645617, -0.17152028], [ 2.14477087, 0.14940101], [-0.42352021, 1.8825546 ]]) 12345data[data[:,0]&lt;0,2:4] = 0data#이렇게 구한 열값에 0을 대입하면 아래와 같은 결과를 얻을 수 있다. array([[-0.78574336, 0.48987839, 0. , 0. ], [-0.3937686 , -0.93822294, 0. , 0. ], [ 1.43828557, 0.47514969, -0.08924484, -0.96863949], [ 0.38315778, 0.52111372, 0.05168264, -0.73003927], [ 1.22600484, -0.31477497, -0.70510052, -1.42081814], [-0.76256766, 0.61905043, 0. , 0. ], [ 0.72534189, -2.13280186, 0.72306828, 1.18772154], [ 1.31611304, 0.98261818, 0.38594941, -0.25431404]])","link":"/2021/11/02/numpy/"},{"title":"파이썬 시각화 1","text":"파이썬 시각화 .legend()(범례)는 그래프에 데이터의 종류를 표시하기위한 메서드다. 그래프 영역에 범례를 나타내기 위해선 먼저 plot() 함수에 label 문자열을 지정한다. 1234567891011121314151617181920# 파이썬 시각화를 위한 모듈세팅import matplotlib.pyplot as plt# 데이터 준비dates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]# 하나의 ax 만을 가지는 하나의 figure 생성# figure 는 그래프를 그릴 공간을 의미하고 ax(axes)는 공간에 내가 사용할 부분을 의미한다.fig, ax = plt.subplots()# 그래프 그리기ax.plot(dates, min_temperature, label = &quot;Min Temp&quot;)ax.plot(dates, max_temperature, label = &quot;Max Temp&quot;)ax.legend()plt.show() 123456789101112131415import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10,6))# 위의 코드와 진행은 동일하지만, figure의 사이즈를 지정해준다.axes.plot(dates, min_temperature, label = 'Min Temperature')axes.plot(dates, max_temperature, label = 'Max Temperature')axes.legend()plt.show() 12print(fig)print(axes) Figure(720x432) AxesSubplot(0.125,0.125;0.775x0.755) Pyplot API + 객체지향 API Pyplot API : 이전절에 소개한 Matlab과 같이 커맨드 방식. matplotlib.pyplot 모듈에 함수로 정의되어 있음. 객체지향 API : matplotlib이 구현된 객체지향라이브러리를 직접 활용하는 방식. Pyplot API는 결국 객체지향 API로 편의함수를 구현한 것 뿐이기에 세밀한 제어를 위해서 객체지향 API를 사용해야한다. 12345678910import matplotlib.pyplot as pltimport numpy as npx = np.linspace(0,1,50)y1 = np.cos(4*np.pi*x)y2 = np.cos(4*np.pi*x)*np.exp(-2*x)fig,ax = plt.subplots(figsize=(10, 6)) # plt.subplots() 편의 함수는 Figure 객체를 생성하고 Figure.subplots()를 호출하여 리턴ax.plot(x,y1,'r-*',lw=1)ax.plot(x,y2,'b--',lw=1) [&lt;matplotlib.lines.Line2D at 0x7f83450f0690&gt;] 주가 데이터 패키지를 받아와 시각화 표현 예시 Yahoo Finance 사이트에서 주가데이터를 받아와본다. 먼저 !pip install yfinance 를 통해 패키지 설치 import fix_yahoo_finance as yf Yahoo 데이터를 yf에 임포트 해준다. import yfinance as yf yf에 임포트해준다. 12345678910111213141516!pip install yfinanceimport fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-08-01', '2020-08-01')ts = data['Open']fig, ax = plt.subplots(figsize=(10, 6)) # 직접 Figure 객체 생성# ax= fig.subplots() # 직접 axes를 생성ax.plot(ts) # 생성된 axes 에 대한 plot() 멤버 직접 호출 ax.set_title('Stock Market fluctuation of AAPL')ax.legend(labels=['Price'], loc='best')ax.set_xlabel('Date')ax.set_ylabel('Stock Market Open Price')plt.show() Requirement already satisfied: yfinance in /usr/local/lib/python3.7/dist-packages (0.1.64) Requirement already satisfied: numpy&gt;=1.15 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.19.5) Requirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.7/dist-packages (from yfinance) (0.0.9) Requirement already satisfied: lxml&gt;=4.5.1 in /usr/local/lib/python3.7/dist-packages (from yfinance) (4.6.4) Requirement already satisfied: pandas&gt;=0.24 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.1.5) Requirement already satisfied: requests&gt;=2.20 in /usr/local/lib/python3.7/dist-packages (from yfinance) (2.23.0) Requirement already satisfied: python-dateutil&gt;=2.7.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2.8.2) Requirement already satisfied: pytz&gt;=2017.2 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2018.9) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.7/dist-packages (from python-dateutil&gt;=2.7.3-&gt;pandas&gt;=0.24-&gt;yfinance) (1.15.0) Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (1.24.3) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (3.0.4) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2.10) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2021.5.30) [*********************100%***********************] 1 of 1 completed 막대 그래프 작성법 import calendar 을 통해 캘린더 데이터를 받아온다. for문을 통해 조건을 반복해 1~12월까지 반복해준다. 1234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npimport calendar # calendar 함수를 임포트 해준다.month_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]sold_list = [300, 400, 550, 900, 600, 960, 900, 910, 800, 700, 550, 450]fig, ax = plt.subplots(figsize=(10,6))plt.xticks(month_list, calendar.month_name[1:13], rotation=90)# .xticks() 는 x축에 눈금을 표시하는 함수입니다.# .yticks() 는 y축에 눈금을 표시해준다.plot = ax.bar(month_list, sold_list)for rect in plot: print(&quot;graph:&quot;, rect) height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.002*height,'%d' % int(height), ha='center', va='bottom')plt.show() graph: Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) graph: Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) graph: Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) graph: Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) graph: Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) graph: Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) graph: Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) graph: Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) 막대 그래프 해석 막대형 그래프는 범주 데이터를 요약하는 방법이다. 위의 그래프는 1월~12월까지의 개월을 calendar 함수를 통해 각 월별 이름을 받아와 월 별 데이터 범주 값을 나타내주고 있다. 산점도 그래프 작성법 import seaborn as sns 은 Matplotlib을 기반으로 다양한 색상 테마와 통계용 차트 등의 기능을 추가한 시각화 패키지이다. # sns.scatterplot(x='total_bill', y='tip', data=tips) 와 같이 각각 선언하지 않고 한번에 하는 것도 가능하다. 1234567891011121314151617import matplotlib.pyplot as pltimport seaborn as sns# 내장 데이터tips = sns.load_dataset(&quot;tips&quot;) # seaborn에서 제공하는 데이터를 불러온다.x = tips['total_bill']y = tips['tip']# sns.scatterplot(x='total_bill', y='tip', data=tips)fig, ax = plt.subplots(figsize=(10, 6))ax.scatter(x, y) # x축과 y축을 그래프에 지정ax.set_xlabel('Total Bill') # x축 변수명 선언ax.set_ylabel('Tip') # y축 변수명 선언ax.set_title('Tip ~ Total Bill') # 그래프 타이틀 선언fig.show() 산점도 그룹화 그래프 작성법 label, data = tips.groupby('sex') 위 코드를 통해 tips의 데이터를 sex로 그룹화를 진행해준다. 1label, data = tips.groupby('sex') 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport seaborn as snstips['sex_color'] = tips['sex'].map({&quot;Female&quot; : &quot;#0000FF&quot;, &quot;Male&quot; : &quot;#00FF00&quot;})# 남성과 여성의 변수명과 색상을 설정해준다.fig, ax = plt.subplots(figsize=(10, 6))for label, data in tips.groupby('sex'): # 그룹화한 변수를 불러와 준다. ax.scatter(data['total_bill'], data['tip'], label=label, color=data['sex_color'], alpha=0.5) # scatter를 이용해 점을 찍어준다. # alpha=n 은 점의 크기 ax.set_xlabel('Total Bill') ax.set_ylabel('Tip') ax.set_title('Tip ~ Total Bill by Gender')ax.legend()fig.show() 산점도 그래프 해석 두 변수 간의 영향력을 보여주기 위해 가로 축과 세로 축에 데이터 포인트를 그리는 데 사용된다. 산점도는 두 변수간의 상관 관계를 나타내주는데, 점이 산점도에서 직선에 가까운 경우 두 변수의 상관관계가 높다고 본다. 점이 균등하게 분산되어 있는 경우 상관관계가 낮거나 0에 가깝다. 두 변수가 다른 변수와 모두 연관될 수 있다. 즉, 우연한 일치로 인해 상관관계가 생성될 수 있다. 그러므로 상관관계만으로 인과관계를 장담할 수 없다. 산점도는 분석을 할 때 참조선이나 곡선 유형을추가하여 일반적으로 사용된다. 히스토그램 그래프 작성법 seaborn 에 저장된 titanic 데이터 프레임의 age 데이터만을 가져온다. 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터 titanic = sns.load_dataset('titanic')age = titanic['age']bins = 21# 가로축 구간 갯수 지정#nbins = 21 로 작성해도 상관없다.fig, ax = plt.subplots(figsize=(10, 6))ax.hist(age, bins = bins)# 히스토그램의 가로축을 지정해주는 함수 .hist()ax.set_xlabel(&quot;Age&quot;)ax.set_ylabel(&quot;Frequency&quot;)ax.set_title(&quot;Distribution of Age in Titanic&quot;)ax.axvline(x = age.mean(), linewidth = 2, color = 'r')# 히스토그램의 평균값을 선으로 나타내주는 함수 .axvline()fig.show() 히스토그램 그래프 해석 히스토그램은 한개의 변수의 구간별 빈도를 나태난다. 위의 표는 age 구간별로 탑승객들의 빈도수를 나타내준다. 박스플롯 그래프 작성법12345678910111213import matplotlib.pyplot as pltimport seaborn as snsiris = sns.load_dataset('iris')data = [iris[iris['species']==&quot;setosa&quot;]['petal_width'], iris[iris['species']==&quot;versicolor&quot;]['petal_width'], iris[iris['species']==&quot;virginica&quot;]['petal_width']]fig, ax = plt.subplots(figsize=(10, 6))ax.boxplot(data, labels=['setosa', 'versicolor', 'virginica'])fig.show() 박스플롯 그래프 해석 박스플롯은 데이터의 집합의 범위와 중앙값을 빠르게 확인 할 수 있다. 또, 통계적 이상치 또한 나타내준다. 위의 그래프의 경우 iris(꽃) 데이터의 species(종) 데이터 부분에서 3가지 품종(setosa,versicolor, virginica) 데이터의 수치를 표현한다. 그래프의 각각 의미는 최댓값 제 1사분위(Q1) 중앙값(제 2사분위(Q2)) 제 3사분위(Q3) 최솟값 최솟값과 최댓값을 넘어가는 위치의 값은 이상치라 부른다. 히트맵 matplotlib 모듈에는 히트맵을 바로 사용할 수 있는 함수가 존재하지 않는다. 그럼으로 get_cmap() 를 통해 바로 가져오지 않고 imshow() 함수를 활용하여 가져온다. 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터flights = sns.load_dataset(&quot;flights&quot;)flights = flights.pivot(&quot;month&quot;, &quot;year&quot;, &quot;passengers&quot;)fig, ax = plt.subplots(figsize=(12, 6))im = ax.imshow(flights, cmap = 'YlGnBu')# 히트맵의 색상을 지정해준다.ax.set_xticklabels(flights.columns, rotation = 20)ax.set_yticklabels(flights.index, rotation = 10)fig.colorbar(im)# 그래프 우측에 구간별 컬러바를 나타내는 함수fig.show() 히트맵 그래프 해석 히트맵은 다양한 값을 갖는 숫자 데이터를 열분포 형태와 같이 색상을 이용해 직관적으로 나타낸 그래프다. x축과 y축을 범주형 변수로 하고 각 칸에 수치형 변수를 채운다. 구체적인 수치가 없어도 많은 데이터의 패턴을 나타내는데 주로 사용된다. 위의 데이터의 경우 1950 ~ 1955년 사이 2~7월 사이의 비행기 탑승객의 수를 나타내준다. Seaborn Seaborn 라이브러를 활용해서 다양한 통계 그래프를 그릴 수 있다. 산점도, 회귀선이 있는 선점도 작성법 -%matplotlib inline 는 출력옵션의 한 종류로, 이미지, 사운드, 애니메이션 등으로 표현되는 객체를 Jupyter등의 프론트에서 표시되게 하는 기능을 한다. 123456789%matplotlib inline import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)sns.scatterplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips)plt.show() 12345678910111213141516fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(15, 5))# nrows = 행, ncols = 열sns.regplot(x = &quot;total_bill&quot;, #x축 지정 y = &quot;tip&quot;, #y축 지정 data = tips, ax = ax[0], # 그래프 구분 넘버링 fit_reg = True) # 회귀선 표시 유무sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[1], fit_reg = False)plt.show() 산점도, 회귀선 그래프 해석 norws는 출력의 행의 갯수, ncols는 열의 갯수를 의미한다. ax = ax[]의 윗줄에 지정한 범위만큼의 값을 넣으면 각 그래프별로 다른 데이터를 넣을 수 있다. regplot() 함수를 이용해 회귀선을 나타냈다. regplot() 함수 안에 있는 fit_reg 를 True로 할 경우 회귀선이 나타나고, False로 하면 회귀선이 나오지 않는다. 히스토그램/커널 밀도 그래프12345678import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)sns.displot(x = &quot;tip&quot;, data = tips)plt.figure(figsize=(10, 6))plt.show() &lt;Figure size 720x432 with 0 Axes&gt; 123sns.displot(x=&quot;tip&quot;, kind=&quot;kde&quot;, data=tips)plt.show()# 커널 밀도 그래프 추가 123sns.displot(x=&quot;tip&quot;, kde=True, data=tips)plt.show()# 위의 두 그래프를 합쳐준다. 박스플롯123sns.boxplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips)sns.swarmplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips, alpha = .25)plt.show() 막대 그래프12sns.countplot(x = &quot;day&quot;, data = tips)plt.show() 123456ax = sns.countplot(x = &quot;day&quot;, data = tips, order = tips['day'].value_counts().index)for p in ax.patches: height = p.get_height() ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9)ax.set_ylim(-5, 100)plt.show() 12345678ax = sns.countplot(x = &quot;day&quot;, data = tips, hue = &quot;sex&quot;, dodge = True, order = tips['day'].value_counts().index)for p in ax.patches: height = p.get_height() ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9)ax.set_ylim(-5, 100)plt.show()","link":"/2021/11/03/data-visualization/"}],"tags":[{"name":"Coalb","slug":"Coalb","link":"/tags/Coalb/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"파이썬","slug":"파이썬","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Pandas","slug":"Pandas","link":"/tags/Pandas/"},{"name":"Statistics","slug":"Statistics","link":"/tags/Statistics/"},{"name":"SPSS","slug":"SPSS","link":"/tags/SPSS/"},{"name":"numpy","slug":"numpy","link":"/tags/numpy/"},{"name":"colab","slug":"colab","link":"/tags/colab/"},{"name":"visualization","slug":"visualization","link":"/tags/visualization/"}],"categories":[{"name":"블로그","slug":"블로그","link":"/categories/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"파이썬","slug":"파이썬","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"통계","slug":"통계","link":"/categories/%ED%86%B5%EA%B3%84/"},{"name":"github","slug":"블로그/github","link":"/categories/%EB%B8%94%EB%A1%9C%EA%B7%B8/github/"},{"name":"파이썬 문법","slug":"파이썬/파이썬-문법","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%AC%B8%EB%B2%95/"},{"name":"numpy","slug":"파이썬/numpy","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/numpy/"},{"name":"Pandas","slug":"파이썬/Pandas","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/Pandas/"},{"name":"통계 이론","slug":"통계/통계-이론","link":"/categories/%ED%86%B5%EA%B3%84/%ED%86%B5%EA%B3%84-%EC%9D%B4%EB%A1%A0/"},{"name":"데이터 시각화","slug":"파이썬/데이터-시각화","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94/"}]}